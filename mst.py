from ast import List
from mpi4py import MPI
import numpy as np
import sys
from utils.graph_generator import GraphGenerator
from utils.graph_utils import GraphUtils
from utils.cluster_edge import ClusterEdge

# Initialize MPI
comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()

num_vertex_local = int(sys.argv[1])
expected_degree = int(sys.argv[2])
max_weight = int(sys.argv[3])

# [rank * num_vertex_local, (rank + 1) * num_vertex_local) 
vertex_local_start = rank * num_vertex_local
num_vertex = num_vertex_local * expected_degree

# Generating graph
# Currently generated by each machine, might later move to rank 0 and use send/recv
graph_generator = GraphGenerator(
  comm_rank=rank,
  comm_size=size,
  expected_degree=expected_degree,
  max_weights=max_weight,
  num_vertex_local=num_vertex_local,
)

edges_local, weights_local, chosen_edges_local = graph_generator.generate()

# phase
k = 0
'''
# which cluster each vertex is in (not local vertices)
# leader of each vertex

# Option 1 shared memory clusters array
# Option 2 each node hold a copy of the array and update it end of each phase (current solution)
'''

# vertex -> cluster leader (will be updated by rank 0 each iter)
cluster_leaders = np.arange(0, num_vertex)
cluster_sizes = np.ones(num_vertex)
num_cluster = num_vertex

t_start = MPI.Wtime()

while True:

  # Step 1
  sendbuf = [[] for _ in range(size)]

  for vertex_local in range(0, num_vertex_local):
    vertex = vertex_local + vertex_local_start
    vertex_cluster = cluster_leaders[vertex]

    to_clusters_edges = GraphUtils.get_min_weight_to_cluster_edges(
      vertex_local=vertex_local,
      vertex=vertex,
      chosen_edges_local=chosen_edges_local,
      cluster_leaders=cluster_leaders,
      edges_local=edges_local,
      weights_local=weights_local
    )

    for edge in to_clusters_edges:
      cluster_leader_machine = GraphGenerator.get_vertex_machine(cluster_leaders[edge.to_cluster])

      sendbuf[cluster_leader_machine].append(edge)

  recvbuf = comm.alltoall(sendbuf)  

  # Step 2
  cluster_edges = [[] for _ in range(num_vertex_local)]
  for edges in recvbuf:
    for edge in edges:
      cluster_edges[edge.to_cluster - vertex_local_start].append(edge)

  for leader_vertex in cluster_edges:




  # Alltoall 



  if num_cluster == 1:
    break

  k += 1

t_end = MPI.Wtime()
